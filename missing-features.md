The core V1 flow from the README is present: /api/upload/floorplans, /api/generate-plan, /api/download/{id} and /api/convert-plan are wired up, the Gemini client produces plan JSON, DOCX files are generated, and the React UI exposes upload/check-box/configure/preview/download workflows (app/api/routes.py (lines 55-135), app/services/gemini_client.py (lines 149-216), app/services/docx_generator.py (lines 8-39), frontend.jsx (lines 259-752)). Admin endpoints/UI for API keys and the system prompt also match the README’s architecture (app/api/routes.py (lines 170-220), frontend.jsx (lines 1206-1366)).

Partially Implemented

Reference-measurement handling for missing m²: the UI collects referenceLabel/referenceWidth when “Areal (m²) er markert” is unchecked and sends them to the backend (frontend.jsx (lines 190-349)), but analyze_floorplan only mentions has_room_names, has_area, and reference_unit in the Gemini prompt and drops the actual measurement data (app/services/gemini_client.py (lines 149-169)), so m² inference can’t work as described.
Multi-floor/V2 flow: the backend does merge rooms from multiple file IDs (app/api/routes.py (lines 82-110)), yet the preview remains a single flat table without grouping by floor/building as promised (“Show each floor’s rooms grouped”) and no metadata from different uploads is surfaced (frontend.jsx (lines 668-705)).
Conversion flow: /api/convert-plan simply decodes the uploaded bytes as UTF‑8/Latin‑1 text and returns JSON with no DOCX output (app/api/routes.py (lines 119-135)), while the Converter view only shows the table and offers no download option or reuse of docx_generator (frontend.jsx (lines 758-837)). Binary DOCX/PDF inputs therefore aren’t really supported.
Batch testing workflow: there are batch endpoints and a UI, but BatchRunner just spins an in-memory loop per file with no queue, persistence, or metrics (app/services/batch_runner.py (lines 8-61)). /batch/results only returns raw plans, the SQLite schema lacks job/result tables (app/db/database.py (lines 10-44)), and the UI shows only basic status with no success rate/quality metrics or downloads (frontend.jsx (lines 843-1019)). Gemini’s Batch API/caching isn’t used anywhere.
/upload/external-plan is exposed but never connected to the converter flow—the converter endpoint expects a fresh file upload instead of accepting uploaded IDs, so the multi-step flow in the README isn’t achievable (app/api/routes.py (lines 71-75), 119-135).
Not Implemented

Template-aware generation (README V3/Phase 3): template uploads are stored, but analyze_template just returns the filename and there is no TemplateSchema model or prompt logic to “learn structure, categories, and wording” from the template (app/api/routes.py (lines 63-107), app/services/gemini_client.py (lines 171-186), app/models/schemas.py (lines 40-140)). The generated plan merely includes the template name string, so template-conditioned output is absent.
Batch analytics/admin reporting (README Phase 5.3–5.4): there is no database model for jobs/results, no aggregate success/error metrics, and no admin UI for monitoring datasets; the current implementation only shows a transient status counter in the Batch view (app/services/batch_runner.py (lines 8-61), frontend.jsx (lines 939-1019)).
Performance features promised in Phase 2.3 (Gemini Batch API use, caching) are nowhere in the codebase; the Gemini client only exposes synchronous per-file calls (app/services/gemini_client.py (lines 90-216)).
Natural next step: decide whether to flesh out the missing template conditioning, conversion DOCX output, and batch analytics, or trim those promises from the README so expectations match what’s currently shipped.